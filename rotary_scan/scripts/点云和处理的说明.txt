本文件用于解释点云的数据格式和如何得到点，只是为了更好的理解，在实际使用处理点云时可以用ROS现成的包，如pcl_ros。

【解释一下点云处理的.py文件】
python文件
http://docs.ros.org/api/sensor_msgs/html/point__cloud2_8py_source.html

【PointCloud2格式】
cloud是一个PointCloud2类的对象，其定义在http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html

.headear是一个类，里面的数直接用cloud.header.seq=159之类的赋值即可，frame_id="laser"显然是字符串
.fields是一个list，每个元素都是一个PointField类的对象，用PointField('x', 0, PointField.FLOAT32, 1)这种方法定义

在python里.data是一个字符串或buffer而不是整数的list。显示的list里的每个整数是每个字符的Ascii码。也就是说显示的是data: [118,9]，那么实际data='v\t'
在ROS里data是8位无符号整数的数列
在python里data只是一串以字符串格式存放的数据，其对应的字符串没有意义

【read_points()】
返回值是generator，每次迭代得到一个点，每个点是一个tuple。另一个函数read_points_list()调用了read_points()，返回值是list。
参数里，field_names的类型是字符串的列表，列表里写要读取的参数名,比如['x']或['x','y']这样，None代表读取fields里列出的所有参数

把data的数据解码所用的函数是python struct模块的Struct(fmt).unpack_from(data,offset)，fmt是解码时的格式，offset就是从data的哪一位开始读，data就是前面PointCloud2格式里提到的以字符串格式存放的数据

由函数_get_struct_fmt(is_bigendian, fields, field_names)把cloud的各个参数翻译成unpack_from的格式参数fmt，fmt是一个字符串

field_names=None时，fmt的值是'<ffff'，第一个字符'<'表示is_bigendian==False，如果是'>'那么is_bigendian==True

field_names改变时fmt的变化：
fmt		xyzi
<ffff		1111
<f		1000
<xxxxf		0100
<xxxxxxxxf	0010
<xxxxxxxxxxxxf	0001
<ff		1100
<fff		1110
<xxxxff		0110
<fxxxxxxxxf	1001

xyzi值只是一种标记，比如xyzi=1001时输入的参数field_names=['x','intensity']

【解释一下点云格式】
从终端的数据格式和ROS文档知道，传感器一帧数据有6096个8位无符号整数，每16个数是一个点
点有4个参数，x,y,z,intensity，每个参数的数据类型都是ROS的Float32

以第一个点为例，数据在data的前16个数里：118,9,11,190,50,203,198,191,0,0,0,0,0,0,0,0
根据read_points()的结果，这个点的x,y,z,intensity分别是-0.1357782781124115, -1.5530760288238525, 0.0, 0.0
cloud.fields里，x,y,z,intensity的offset值分别是0,4,8,12
既然是Float32，那么一个数是32位，即4个字节。4个数16个字节。根据offset，猜想在16字节的点的数据中，1~4字节是x，5~8字节是y，9~12字节是z，13~16字节是intensity。以下验证。

第一个点数据如下：

	十进制	二进制		Float32
x
	118	01110110	-0.1357782781124115
	9	00001001
	11	00001011
	190	10111110
y	
	50	00110010	-1.5530760288238525
	203	11001011
	198	11000110
	191	10111111
z
	0			0.0
	0	
	0
	0
intensity
	0			0.0
	0
	0
	0

十进制是终端打印出来的已知数据，二进制由十进制转换而来，浮点数由read_points()的结果得来，因此需要验证一下二进制和浮点数是否一致，一致的话说明对数据的格式理解正确

（【浮点数格式说明】
IEEE规定32位浮点数的格式是1个符号位，8个指数位，23个精度位

对于8位浮点数，当指数位等于0或者大于254时可以表示非规约形式浮点数，即+-0，+-无穷，NaN之类的数

8个指数位得到一个数，减去127为实际指数（127为固定偏移值），23个精度位，顺序罗列了小数

比如表示浮点数-6.625D
转换成二进制-110.101B，科学计数-1.10101B *2^2

负数，符号位是1
指数2，指数位129，10000001
小数.10101，小数位10101000000000000000000
因此整个浮点数是1 10000001 10101000000000000000000
在内存中8位1字节 11000000 11010100 00000000 00000000
）

x是负数，如果按写的顺序，32个二进制数从头到尾和从尾到头读，符号位都不对
考虑到is_bigendian==False，应该是高字节低地址，那么x是从第四个字节往前读，也就是190,11,9,118的顺序
整理x数据的顺序10111110 00001011 00001001 01110110
即1 01111100 00010110000100101110110
符号-，指数124-127=-3，小数00010110000100101110110
x=-1.00010110000100101110110B *2^-3
=-0.00100010110000100101110110B
=-0.1357782781124115
和函数返回结果一致

y
10111111 11000110 11001011 00110010
1 01111111 10001101100101100110010
符号-，指数127-127=0，小数10001101100101100110010
y=-1.10001101100101100110010B*2^0
=1.5530760288238525，一致


Excel导入用381个点，用x，y值作图，形状和RViz差不多吧，传感器在(0,0)
